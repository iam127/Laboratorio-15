test_results = []
def record_test(test_name, condition):
    emoji = "✅" if condition else "❌"
    test_results.append(f"{emoji} {test_name}")

class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left  = None
        self.right = None

class BinarySearchTree:
    def __init__(self):
        self.root = None

    def search(self, value) -> bool:
        current = self.root
        while current:
            if value == current.value:
                return True
            elif value < current.value:
                current = current.left
            else:
                current = current.right
        return False

    def insert(self, value) -> bool:
        if not self.root:
            self.root = TreeNode(value)
            return True

        current = self.root
        while True:
            if value == current.value:
                return False  # Duplicate
            elif value < current.value:
                if current.left:
                    current = current.left
                else:
                    current.left = TreeNode(value)
                    return True
            else:
                if current.right:
                    current = current.right
                else:
                    current.right = TreeNode(value)
                    return True

    def update(self, old_value, new_value) -> bool:
        if not self.delete(old_value):
            return False
        return self.insert(new_value)

    def delete(self, value) -> bool:
        self.root, deleted = self._delete_recursive(self.root, value)
        return deleted

    def _delete_recursive(self, node, value):
        if not node:
            return node, False

        if value < node.value:
            node.left, deleted = self._delete_recursive(node.left, value)
            return node, deleted
        elif value > node.value:
            node.right, deleted = self._delete_recursive(node.right, value)
            return node, deleted
        else:
            # Node found
            if not node.left and not node.right:
                return None, True  # Leaf node
            elif not node.left:
                return node.right, True
            elif not node.right:
                return node.left, True
            else:
                # Two children: Find inorder successor
                successor = self._get_min(node.right)
                node.value = successor.value
                node.right, _ = self._delete_recursive(node.right, successor.value)
                return node, True

    def _get_min(self, node):
        while node.left:
            node = node.left
        return node

def test_o7_1():
    # o7.1.1 Insert & Search
    bst = BinarySearchTree()
    record_test("o7.1.1 insert/find",
        bst.insert(5) is True and bst.insert(3) and bst.insert(7)
        and bst.search(3) is True and bst.search(8) is False
    )
    # o7.1.2 Update Existing
    bst = BinarySearchTree()
    for v in [10,5,15]: bst.insert(v)
    record_test("o7.1.2 update",
        bst.update(5,6) is True and bst.search(6) and not bst.search(5)
    )
    # o7.1.3 Delete Leaf & One/Two-Child
    bst = BinarySearchTree()
    for v in [20,10,30,5,15]: bst.insert(v)
    record_test("o7.1.3 delete",
        bst.delete(5) and bst.delete(30) and bst.delete(10)
        and not bst.search(5) and not bst.search(30) and not bst.search(10)
    )
    # o7.1.4 Validation: Duplicate Insert
    bst = BinarySearchTree()
    bst.insert(2)
    record_test("o7.1.4 dup insert",
        bst.insert(2) is False and bst.search(2) is True
    )
    # o7.1.5 Return-Type Verification
    bst = BinarySearchTree()
    record_test("o7.1.5 types",
        isinstance(bst.insert(1), bool)
        and isinstance(bst.update(1,2), bool)
        and isinstance(bst.delete(1), bool)
    )

# 🚀 Run tests
test_o7_1()

# 📋 Summary
for r in test_results:
    print(r)
